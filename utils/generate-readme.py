import os
import os.path as osp
from glob import glob
import re, json, subprocess, shlex
from copy import deepcopy
from common import *
import importlib  
solver = importlib.import_module("gt-to-solver")

############### CONSTANTS START ###############
to_run = [
        "agreement",
        "alternate-color",
        "alternation",
        "aphaeresis",
        "apocope",
        "assimilation",
        "breaking",
        "circle-at-ends",
        "devoicing",
        "meeussen",
        "partition",
        "shield",
        "spy",
        "threepack",
        "train",
        # "cones*",
        # "neutralization",
        ]

skip_list = [
        'devoicing'
        ]

in_dir  = "data/clevr-cleaned-puzzles"
md_dir  = "data/autogenerated_md"
# md_dir  = "data/clevr-cleaned-puzzles"

get_float = lambda img_pths: "\n".join([f'<img src="{pth}" width="320" />' for pth in img_pths]) 

get_md = lambda name, train_imgs, test_imgs, solver_output, solver_flags, pipeline_output, baseline_out, english_desc: f"""
# Puzzle \#{name}

## Example Images
<p float="left">
{get_float(train_imgs)}
</p>


## Candidate Images
<p float="left">
{get_float(test_imgs)}
</p>

The leftmost testimage is the intended answer.

## Pipeline Output

Results below are generated on inferred pipeline. That is: `{{groundtruth}} -> {{generator}} -> {{infernce}} -> {{solver}} -> {{output}}`.

```plaintext
{pipeline_output}
```

## Solver Output

Results below are generated on raw description. That is: `{{groundtruth}} -> {{solver}} -> {{output}}`.

```plaintext
{solver_output}

```

## Baseline Output

Results below are generated from a neural-network based image similarity baseline. That is: `{{groundtruth}} -> {{generator}} -> {{image-similarity-baseline}} -> {{output}}`

```plaintext
{baseline_out}
```

<!---
## Puzzle Flags
The following flags were used for output generation: `{solver_flags}`
## English Description

Intended Concept: {english_desc if len(english_desc) else 'NULL'}
-->
"""

rotate_solver_out = lambda s: s.replace("left", "<TOK1>") \
                        .replace("right", "<TOK2>") \
                        .replace("front", "right") \
                        .replace("behind", "left") \
                        .replace("<TOK1>", "behind") \
                        .replace("<TOK2>", "front") \

############### CONSTANTS END ###############
############### HELPERS START ###############

def extract_gt(pth):
    print(pth)
    return (pth, (None, None))

def smallest_solver(absdir, puzzle_name):
    running = True
    c = 1
    while(running):
        pz_flags = flags_no_c[puzzle_name]
        if puzzle_name not in skip_list: pz_flags += f" -C {c}"
        print(f"Trying {puzzle_name} with flags: {pz_flags}")
        solver_out = solver.run_solver(absdir, pz_flags, False)
        concepts = parse_solver_output(solver_out)
        if len(concepts) != 0:
            break
        c += 1

    selected_concepts = list()
    for concept in concepts:
        selected_concepts.append(concept['concept'].group(0))
        selected_concepts.append(concept['candidate'].group(0))

    return pz_flags, "\n".join(selected_concepts)
    # return pz_flags, "\n".join(list(map(lambda x: x['concept'].group(0), concepts)))





def generate_md(absdir, puzzle_name):
    md_pth = osp.join(md_dir, str(pz2count[puzzle_name]), "README.md")
    train_imgs = sorted(list(map(lambda pth: osp.relpath(pth, osp.dirname(md_pth)), glob(osp.join(absdir, "*[3-9].png")))))
    test_imgs =  sorted(list(map(lambda pth: osp.relpath(pth, osp.dirname(md_pth)), glob(osp.join(absdir, "*[0-2].png")))))

    solver_flags, solver_out = smallest_solver(absdir, puzzle_name)
    solver_out = rotate_solver_out(solver_out)


    md_str = get_md(str(pz2count[puzzle_name]), train_imgs, test_imgs, solver_out, solver_flags, intended_concept[puzzle_name])
    print("OUT", md_pth)
    os.makedirs(osp.dirname(md_pth), exist_ok=True)
    with open(md_pth, 'w') as fp:
        fp.write(md_str)



############### HELPERS END ###############

if __name__ == '__main__':
    assert osp.exists(in_dir), f"Path not found: {in_dir}"
    global pz2count
    puzzles, pz2count, pz_count = [], {}, 0
    for (absdir, folders, files) in os.walk(in_dir, followlinks=False):
        if absdir == in_dir:
            puzzles = [osp.join(in_dir, p) for p in folders]
        if absdir in puzzles:
            print(absdir)
            puzzle_name = osp.basename(absdir)
            if ("*" in puzzle_name) or (puzzle_name not in to_run):
                print("SKIPPING", puzzle_name)
                continue
            pz2count[puzzle_name] = pz_count
            generate_md(absdir, puzzle_name)
            pz_count += 1
    
    with open(osp.join(md_dir, "mapping.json"), 'w') as fp:
        json.dump(pz2count, fp)