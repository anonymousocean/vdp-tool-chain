import os
import os.path as osp
from glob import glob
import re, json, subprocess, shlex
from copy import deepcopy
import numpy as np
from common import *
import importlib  
solver = importlib.import_module("gt-to-solver")

############### CONSTANTS START ###############
to_run = [
        "agreement",
        "alternate-color",
        "alternation",
        "aphaeresis",
        "apocope",
        "assimilation",
        "breaking",
        "circle-at-ends",
        "threepack",
        "train",
        "partition",
        "spy",
        "shield",
        "devoicing",
        "meeussen",
        # "neutralization",
        # "cones*",
        ]

skip_list = [
        'devoicing'
        ]

in_dir  = "data/clevr-cleaned-variants"
md_dir  = "data/autogenerated-variant_md"
# md_dir  = "data/clevr-cleaned-puzzles"

get_float = lambda img_pths: "\n".join([f'<img src="{pth}" width="320" />' for pth in img_pths]) 

get_md = lambda name, train_imgs, test_imgs, solver_output, solver_flags, pipeline_output, baseline_out, english_desc: f"""
# Puzzle \#{name}

## Example Images
<p float="left">
{get_float(train_imgs)}
</p>


## Candidate Images
<p float="left">
{get_float(test_imgs)}
</p>

The leftmost testimage is the intended answer.

## Pipeline Output

Results below are generated on inferred pipeline. That is: `{{groundtruth}} -> {{generator}} -> {{infernce}} -> {{solver}} -> {{output}}`.

```plaintext
{pipeline_output}
```

## Solver Output

Results below are generated on raw description. That is: `{{groundtruth}} -> {{solver}} -> {{output}}`.

```plaintext
{solver_output}

```

## Baseline Output

Results below are generated from a neural-network based image similarity baseline. That is: `{{groundtruth}} -> {{generator}} -> {{image-similarity-baseline}} -> {{output}}`

```plaintext
{baseline_out}
```

<!---
## Puzzle Flags
The following flags were used for output generation: `{solver_flags}`
## English Description

Intended Concept: {english_desc if len(english_desc) else 'NULL'}
-->
"""

rotate_solver_out = lambda s: s.replace("left", "<TOK1>") \
                        .replace("right", "<TOK2>") \
                        .replace("front", "right") \
                        .replace("behind", "left") \
                        .replace("<TOK1>", "behind") \
                        .replace("<TOK2>", "front") \

############### CONSTANTS END ###############
############### HELPERS START ###############

def extract_gt(pth):
    print(pth)
    return (pth, (None, None))

def smallest_solver(absdir, puzzle_name):
    running = True
    c = 1
    while(running):
        base_pz_name = puzzle_name.replace("-fovariant", "-variant").split("-variant")[0]
        pz_flags = flags_no_c[base_pz_name]
        if base_pz_name not in skip_list: pz_flags += f" -C {c}"
        print(f"Trying {puzzle_name} with flags: {pz_flags}")
        try:
            solver_out = solver.run_solver(absdir, pz_flags, False)
            concepts = parse_solver_output(solver_out)
            if len(concepts) != 0:
                break
            c += 1
        except Exception as e:
            return pz_flags, ""

    selected_concepts = list()
    for concept in concepts:
        selected_concepts.append(concept['concept'].group(0))
        selected_concepts.append(concept['candidate'].group(0))

    return pz_flags, "\n".join(selected_concepts)
    # return pz_flags, "\n".join(list(map(lambda x: x['concept'].group(0), concepts)))





def generate_md(absdir, puzzle_name, train_split, test_split):
    md_pth = osp.join(md_dir, str(pz2count[puzzle_name]), "README.md")
    train_imgs = sorted(list(map(lambda pth: osp.relpath(pth, osp.dirname(md_pth)), glob(osp.join(absdir, "*[3-9].png")))))
    test_imgs =  sorted(list(map(lambda pth: osp.relpath(pth, osp.dirname(md_pth)), glob(osp.join(absdir, "*[0-2].png")))))

    base_puzzle_name = puzzle_name.replace("fovariant", "variant").split("-variant")[0]    
    ir_dir = os.path.join("data/inference-outputs/", base_puzzle_name + "-" + os.path.basename(absdir))

    gt_pth = os.path.join(absdir, puzzle_name + "-gt.json" )
    solver.collate_gt_results(gt_pth, train_split, test_split)

    ir_results_pth = os.path.join(ir_dir, "results.json")
    solver.collate_gt_results(ir_results_pth, train_split, test_split)

    solver_flags, solver_out = smallest_solver(absdir, puzzle_name)
    solver_out = rotate_solver_out(solver_out)

    inf_solver_flags, inf_solver_out = smallest_solver(ir_dir, puzzle_name)

    # print(puzzle_name, base_puzzle_name, pz2count.keys(), intended_concept.keys())
    base_name, variant_num = puzzle_name.split("-fovariant-")
    out_pth = os.path.join(in_dir, base_name, f"fovariant-{variant_num}", f"{puzzle_name}.out")
    concepts = out_parser(out_pth)
    raw_solver_out, raw_baseline_out = concepts[:-1], concepts[-1]

    pipeline_out = ( "\n".join([ "\n".join([c['concept'].groups()[0], c['candidate'].groups()[0]])  for c in raw_solver_out]))
    baseline_out = ("\n".join([raw_baseline_out['bscores'].groups()[0], raw_baseline_out['bcandidate'].groups()[1]]) )
    if swapped:
        md_str = get_md(str(pz2count[puzzle_name + '-swap']), train_imgs, test_imgs, solver_out, solver_flags, pipeline_out, baseline_out, intended_concept[base_puzzle_name])
    else:
        md_str = get_md(str(pz2count[puzzle_name]), train_imgs, test_imgs, solver_out, solver_flags, pipeline_out, baseline_out, intended_concept[base_puzzle_name])
    print("OUT", md_pth)
    os.makedirs(osp.dirname(md_pth), exist_ok=True)
    with open(md_pth, 'w') as fp:
        fp.write(md_str)



############### HELPERS END ###############

if __name__ == '__main__':
    assert osp.exists(in_dir), f"Path not found: {in_dir}"
    global pz2count
    puzzles, pz2count, pz_count = [], {}, 0
    for (absdir, folders, files) in os.walk(in_dir, followlinks=False):
        if absdir == in_dir:
            puzzles = [os.path.join(in_dir, p) for p in folders]
        if absdir in puzzles:
            print(absdir)
            puzzle_name = osp.basename(absdir)
            if ("*" in puzzle_name) or (puzzle_name not in to_run):
                print("SKIPPING", puzzle_name)
                continue
            for v_dir in glob(os.path.join(absdir, "*")):
                v_name = os.path.basename(v_dir)
                full_v_name = f"{puzzle_name}-{v_name}"
                gt_pth = os.path.join(v_dir, f"{full_v_name}-gt.json")
                gen_pth = os.path.join(v_dir, f"{full_v_name}.json")
                
                


                pz2count[full_v_name] = pz_count
                train_split = ['3', '4', '5']
                test_split  = ['0', '1', '2']
                generate_md(v_dir, full_v_name, train_split, test_split)
                pz_count += 1
                    
                if len(swap_list[puzzle_name]) > 1:
                    # swapping possible.
                    sl  = set(swap_list[puzzle_name]) - set([0])
                    swap = np.random.choice(list(sl))

                    pz2count[full_v_name + "-swap"] = pz_count
                    train_split = list(map(str, [i if i != swap else 0 for i in [3, 4, 5]]))
                    test_split  = list(map(str, [swap, 1, 2]))
                    generate_md(v_dir, full_v_name, train_split, test_split, swapped=swap)
                    pz_count += 1
    
    with open(osp.join(md_dir, "mapping.json"), 'w') as fp:
        json.dump(pz2count, fp)